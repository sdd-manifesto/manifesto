# The Software Defined Delivery Manifesto

We recognize that delivering useful software shapes our world. We recognize that code is the best way to specify precise action. We recognize that code is only useful when we deliver it.

Delivery is not a detail, it is our job. Now is the time to apply our core skills to our own work. Now is the time to *engineer* our delivery. We divide our work between ourselves and computers: humans for decisions, and automation for tasks.

The work of delivery is inherently unique. Each combination of application, organization, deployment environment, and team has its own context. We recognize that each team needs delivery and automation that comprehends that uniqueness. We recognize that while continuous delivery is essential to meeting business needs, automating all repeated tasks is important.

We accelerate our automation the same way we accelerate application development: with modern architecture and programming languages plus frameworks, libraries, and services for generic capabilities. 


We recognize prior art. This is not a work of invention but of articulation, of a timely and much needed approach.

Delivery infrastructure is now programmable, and we will program it.


## Software Defined Delivery is:

**Core:** Delivery is a fundamental and strategic capability for every software team and organization.
-   **First-class:** Delivery code is production code.
-   **Strategic:** Decide policy at the team and organization level; implement it with precision, without toil, in code.
-   **Evolving:** As we learn, we continually improve our delivery.

**Engineered:** In robust, testable code.
-   **Modern software architecture:** Event-driven and extensible.
-   **Modern programming languages:** Logic is best specified in code, not pictures or GUIs. Scripts don’t scale.
-   **Model-based:** Backed by a model of the software domain, with understanding of code.
-   **Testable:** Enabling short trips to spot errors before production.
-   **Progressive:** Facilitates deployment at any time. Provides controlled, selective rollout of changes to audiences and environments. Allows release to be gradual and deliberate.

**Collaborative:** 
-	**Among people:** Each person can express their expertise in code for everyone’s benefit.
-	**Among software:** We use best-of-breed tools, but how we combine them is unique.
-	**Between people and software:** Collaborative automation enhances our perception and implements our decisions. It brings information and actions to where we are and makes automated behavior comprehensible to us. Using code, we distinguish between a team's shared set of delivery objectives, and their implementations.

**Accelerated:** 
- **Through automation:** We automate repeated tasks to speed our work and avoid errors.
- **Through reuse:** Common functionality is shared between developers, teams, and organizations.

**Observable:** We require common means to observe and troubleshoot what happens in the delivery process as a production system.
-   **Trace:** Observe activity in a system and trace the relationships between actions.
-   **Debug:** Interact with and inspect a delivery flow.
-   **Metrics:** Derive metrics from activity across the entire delivery flow.

**Authors:** (alphabetical by last name): Kenny Bastani, Marc Holmes, Rod Johnson, Jessica Kerr, Mik Kersten, Russ Miles, Erin Schnabel, Matt Stine. With the help and refinement of many members in the community.

© 2019, the above authors, this declaration may be freely copied in any form, but only in its entirety through this notice.


